---
id: cheat-sheet
title: Sitecore Dockerチートシート
sidebar_label: Sitecore Dockerチートシート
---

> **注意:** このページの原文は https://containers.doc.sitecore.com/docs/cheat-sheet です

Dockerの公式ドキュメントは素晴らしいものですが、最初は少し圧倒されるかもしれません。このページでは、ローカルの開発環境でSitecoreをDockerで管理する際に便利なコマンドをいくつか紹介します。
ここでは、コマンドシェルとしてPowerShellを使用することを前提としています。

一般的な
利用可能なコマンドをすべてリストアップします。
docker ヘルプ
ドッカーコンポーズヘルプ

コピー
helpを使うと、特定のコマンドの詳細情報を表示することができます。
docker <コマンド> --help
docker-compose <command> --help

コピー
Docker環境の高レベル情報（バージョン、ルートディレクトリ、デフォルトのアイソレーションモードなど）を表示するには、以下のようにします。
docker info

コピー

画像の管理
画像をリストアップする (中間画像を含む場合は -a を使用)
ドッカーイメージ ls
ドッカーイメージ

コピー
結果は--formatオプションを使ってフォーマットすることができます。有効なプレースホルダーのリストはDockerのドキュメントを参照してください。
画像の削除
docker イメージ rm <イメージ
docker rmi <イメージ

コピー
<image>には、画像のIDかフルネームのどちらかを指定することができます。特筆すべきことは、id はそれを一意に識別するために最低限の文字数しか必要としないということです。例えば、次のような画像リストがあるとします。
リポジトリタグ 画像ID 作成サイズ
mcr.microsoft.com/windows/servercore ltsc2019 8351e66084ac 2ヶ月前 4.82GB
mcr.microsoft.com/windows/nanoserver 1809 880394ef5494 2ヶ月前 251MB

コピー
これら3つのコマンドはすべてナノサーバーイメージを削除します。
docker image rm mcr.microsoft.com/windows/nanoserver
ドッカー rmi 880394ef5494
ドッカーＲＭＩ八十八

コピー
すべてのイメージを削除するには、次のようにします。
docker rmi $(docker images -a -q)

コピー
しかし、より多くの場合は、より選択的に使用したいと思うでしょう。そのためには、findstrと組み合わせた画像リストの書式設定を利用します。例えば、特定の名前やタグを持つすべての画像を削除するには、以下のようにします。
docker rmi $(docker images --format "{{.Repository}}}:{{.Tag}}"|findstr "<search_text>")

コピー
画像の検査
docker イメージ検査 <イメージ
docker inspect <イメージ

コピー
画像の詳細情報が表示されます。より興味深い詳細情報が表示されます。
	- Id - 画像の完全な一意の識別子です。
	- WorkingDir - 画像の中で対話型シェルを実行する際の落とし所です。これは、独自のカスタマイズでイメージを拡張するときに便利になります。
	- Entrypoint - このイメージをコンテナ内で実行する際のデフォルトの入り口。これは、イメージがDocker Composeで使用されているときに知っておくと便利です。
	- VirtualSize - イメージのサイズをバイト単位で指定します。
ここでも出力をフォーマットすることができます。

コンテナを管理する
コンテナをリストアップする (停止したコンテナを含めるには -a を使用します)
ドッカーコンテナ ls
ドッカーピーエス

コピー
f (または --filter) オプションを使って結果をフィルタリングすることができます。例えば、実行中のSitecore CMイメージだけを表示するには、以下のようにします。
docker ps -f "name=cm"

コピー
結果は--formatオプションを使ってフォーマットすることもできます。有効なプレースホルダーのリストはDockerのドキュメントを参照してください。
コンテナの削除 (ボリュームを削除するには -v を使います)
docker コンテナ rm <コンテナ
docker rm <コンテナ

コピー
画像と同様に、<container>にはコンテナID(フルまたはパーシャル)かフルネームを指定できます。
停止しているコンテナをすべて削除するには、次のようにします。
docker rm $(docker ps -a -q)

コピー
(実行中のコンテナを削除するには --force を追加します)。
コンテナの検査
dockerコンテナインスペクション <コンテナ
docker inspect <コンテナ

コピー
コンテナの詳細情報が表示されます。より興味深い詳細情報のいくつかをご紹介します。
	- Id - コンテナの完全な一意の識別子。
	- Image - コンテナが実行しているイメージ。
	- NetworkSettings - ポート、IPアドレス、および任意のエイリアスを含むネットワーク情報。
	- LogPath - コンテナのログファイルへのファイルシステムパスです。
	- Volumes - ホストシステムとコンテナ間のボリュームマッピングを表示します。
	- WorkingDir - コンテナで対話型シェルを実行する際にドロップされる場所です。
ここでも、出力をフォーマットすることができます。
コンテナの起動と停止
コンテナは個別に起動・停止することができます。
docker コンテナ起動 <コンテナ
docker起動 <コンテナ
dockerコンテナの停止 <コンテナ
docker stop <コンテナ

コピー
しかし、Sitecore開発の場合、通常はDocker Composeを使って一度に複数のコンテナを使って作業することになります。
コンテナとローカルファイルシステム間でファイルをコピーする
docker cp <src_path> <container>:<dest_path> の場合
docker cp <コンテナ>:<src_path> <dest_path

コピー
例えば、ファイルをコンテナにコピーするには
docker cp file.txt 2c26f76568d4:/tools/にコピーします。

コピー
またはコンテナからフォルダをコピーします。
docker cp 2c26f76568d4:/inetpub/wwwroot/App_Config/ .

コピー
コンテナはプロセス分離された状態で実行されている必要があります。Hyper-V コンテナに対するファイルシステム操作はサポートされていません。
ログの表示
docker コンテナのログ <コンテナ
docker のログ <コンテナ

コピー
f (または --follow) を使用してログ出力をストリーム配信することができます。
docker logs -f <コンテナ

コピー
Ctrl+Cを入力して終了します。
これらはほとんどのコンテナではかなり大きくなりますので、 --tail や --until オプションを使って制限したいと思うでしょう。例えば、最後の20件のログのみを表示するには、次のようにします。
docker logs -f --tail 20 <コンテナ

コピー

フォーマット結果
Dockerコマンドの多くは結果をフォーマットするために--formatや-fオプションを提供しており、表示用の出力を構築したり、他のスクリプトに渡したりすることができます。フォーマット文字列はGoテンプレートに従っていますので、多少の学習が必要かもしれませんが、一般的には結果から必要な情報を得るのは非常に簡単です。
inspectコマンドの場合、出力データはすでにJSON形式になっているので、データ構造は簡単です。
いくつかの例を紹介します。
コンテナの画像名を取得する
docker inspect --format='{{{.Config.Image}}}' <コンテナ

コピー
コンテナのIPアドレスを取得する
docker inspect --format='{{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}}' <コンテナ

コピー
リストコマンドの場合、出力はテーブル形式になっているので、利用可能なプロパティを見つけるにはもう少し調べる必要があります。Dockerのドキュメントを参照するか（イメージについてはこちら、コンテナについてはこちらを参照）、以下のコマンドを使って出力をJSONとしてフォーマットすることができます。
docker images --format "{{json .}}"
docker ps --format "{{json .}}"

コピー
いくつかの例
カスタム画像リスト
docker images --format "{{.ID}}}. {{{.Repository}}}"

コピー
カスタムコンテナリスト (table ディレクティブを使用)
docker ps --format "table {{.ID}}}t{{.Names}}t{.Ports}}}t{.Status}}"

コピー

画像内での対話型シェルの実行
powershell は、それをサポートしているイメージでのみ使用できます。省略した場合は、デフォルトのcmdシェルが使用されます。
docker run -it --rm <image> [powershell]

コピー
exit と入力すると、コンテナから前のシェルセッションに戻ることができます。
これは新しいコンテナを起動し (run)、対話型シェルにドロップし (-it)、終了後にコンテナを破棄します (--rm)。
デフォルトの ENTRYPOINT によっては、これがすべてのイメージで動作しない場合があることに注意してください。その場合は、デタッチドモードで実行する必要があります。
docker run -d <イメージ

コピー
を実行し、実行中のコンテナで対話型シェルを実行します。

コンテナ内で対話型シェルを実行する
以下のようにすれば、実行中の Windows コンテナ内で対話型のシェルプロンプトを開くことができます。 powershell は、それをサポートしているイメージ上でのみ使用できます。
docker exec -it <コンテナ> powershell
docker exec -it <コンテナ> cmd

コピー
exit と入力して、コンテナから前のシェルセッションに戻ります。

クリーンアップ
Dockerは自動的に未使用のリソースを削除するわけではありません。時間が経つと、不要なリソースが蓄積されてディスクスペースを食いつぶしてしまうことがあります。
これを助けるために最も便利なコマンドは、以下の通りです。
docker system prune

コピー
デフォルトでは、続行を促すプロンプトが表示されます。バイパスするには、-f (または --force) オプションを使用します。
これにより削除されます。
	- 停止しているすべてのコンテナ
	- 少なくとも1つのコンテナで使用されていないすべてのネットワーク
	- すべてのぶら下がり画像（タグ付けされておらず、どのコンテナからも参照されない
	- すべてのビルドキャッシュ
このデフォルトは、一般的にはいつでも使用しても安全です。しかし、以下のオプションを追加することで、もう少し攻撃的に (そして破壊的に) することができます。
	--volumes - 少なくとも 1 つのコンテナで使用されていないすべてのボリュームを削除します。
	- a (または --all) -a (または --all) - 少なくとも 1 つのコンテナに関連づけられていないすべての画像を削除する
個々のDockerオブジェクト（イメージ、コンテナなど）ごとにpruneコマンドがありますが、それらはあまり使われていません。詳細はDockerのドキュメントを参照してください。

DockerのComposeを使う
これらのコマンドは、Compose ファイルの場所から実行されます。Compose ファイルの名前が docker-compose.yml であることを前提としています。また、追加の docker-compose.override.yml があれば、自動的にロードされます。
Compose ファイルの名前が他のものである場合は、-f フラグを使用して明示的に指定します。
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d

コピー
必要な数だけファイルを指定することができます。Compose はそれらのファイルを順番に一つの設定にまとめ、後続のファイルは前のファイルを上書きしたり、追加したりします。
集約された結果を実際に見るには config を使用します。例えば、以下のようになります。
 docker-compose -f docker-compose.yml -f docker-compose.dev.yml config

コピー
これは、結合されたコンパイルファイルや.envなどを含む、解決されたアプリケーションの設定を表示します。これは、Sitecore の世界では /admin/showconfig.aspx に相当するものと考えてください。
各コマンドでは、1つまたは複数のサービスの名前を追加することもできます。これにより、個々のサービス/コンテナをターゲットにすることができます。例えば、次のような Compose ファイルがあるとします。
version. "3"
サービスを提供しています。
  mssql. [...]
  solr: [....] [...]
  id. [...]
  cm. [...]

コピー
を使って id と cm コンテナだけを再起動することができます。
docker-compose restart id cm

コピー
コンテナの作成と起動
docker-compose up -d

コピー
これにより、Composeの設定で定義されたすべてのサービスのコンテナが作成され、実行されます。
d ("detached mode") は、コンテナをバックグラウンドで起動し、実行したままにしておくことを指示します。これを省略すると、コンテナのログが出力され、Ctrl+Cを入力してプロンプトに戻る必要があります。これを行うと、コンテナを停止して削除することもできます。
コンテナの停止
ドッカーコンポーズストップ

コピー
これでコンテナは停止しますが、削除はしません。
コンテナの起動
ドッカーコンポーズ開始

コピー
これにより、以前に停止していた既存のコンテナが起動します。
コンテナの再起動
docker-compose再起動

コピー
これにより、停止しているすべてのコンテナと実行中のコンテナが再起動されます。
コンテナの停止と削除 (ボリュームを削除するには -v を使用)
ドッカーコンポーズダウン

コピー
これにより、すべてのコンテナが潔く停止し、すべて停止したら削除します。upによって作成されたネットワークも削除されます。
コンテナの一覧表示 (停止しているコンテナを含めるには -a を使用)
docker-compose ps

コピー
サービスの名前をリストアップするには、-services オプションを使用します。
docker-compose ps -services

コピー
イメージを構築する
ドッカーコンポーズビルド

コピー
これはビルドを定義しているすべてのサービスのイメージをビルドして作成します。
up で --build フラグを使用すると、最新のコードでコンテナを再ビルドして実行することもできます。
docker-compose up --build -d

コピー
ログの表示
docker-composeログ

コピー
これはすべてのコンテナからのログを表示することに注意してください。tail オプションを使用すると、行数を制限したり、特定のコンテナに対してフィルタリングしたりすることができます。例えば、cm と xconnect コンテナからの最後の 20 件のログエントリのみを表示するには、--tail オプションを使用します。
docker-compose logs --tail 20 cm xconnect

コピー
また、-f (または --follow) を使用してログ出力をストリーム配信することもできます。
docker-compose logs -f --tail 20

コピー
Ctrl+Cを入力して終了します。
